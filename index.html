<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>QR AR Video</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
  <style>
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 9999;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 20px;
      border-radius: 10px;
    }
  </style>
  <script>
    function showLoading(show) {
      const loading = document.getElementById('loading');
      if (loading) loading.style.display = show ? 'block' : 'none';
    }
    // Add camera constraints and handle loading state
    window.addEventListener('load', () => {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const constraints = {
          video: {
            facingMode: 'environment',
            width: { min: 640, ideal: 1920, max: 2560 },
            height: { min: 480, ideal: 1080, max: 1440 },
            aspectRatio: { ideal: 1.7777777778 },
            frameRate: { ideal: 30 },
            // Try to get the best quality camera
            advanced: [
              { focusMode: "continuous" },
              { exposureMode: "continuous" },
              { whiteBalanceMode: "continuous" }
            ]
          }
        };
        navigator.mediaDevices.getUserMedia(constraints)
          .then(() => {
            // Hide loading once camera is ready
            showLoading(false);
            
            // Start preloading videos in background after camera is ready
            setTimeout(() => {
              document.querySelectorAll('video').forEach(video => {
                const dataSrc = video.getAttribute('data-src');
                if (dataSrc) {
                  const preloadLink = document.createElement('link');
                  preloadLink.rel = 'preload';
                  preloadLink.as = 'video';
                  preloadLink.href = dataSrc;
                  document.head.appendChild(preloadLink);
                }
              });
            }, 1000);
          })
          .catch(function(err) {
            console.log("Failed to get camera with constraints", err);
            showLoading(false);
          });
      }
    });
  </script>
</head>

<body style="margin: 0; overflow: hidden;">
  <div id="loading">Loading AR Experience...</div>
  <a-scene embedded arjs='sourceType: webcam; 
            trackingMethod: best;
            debugUIEnabled: true;
            detectionMode: mono;
            patternRatio: 0.75;
            maxDetectionRate: 30;' vr-mode-ui="enabled: false" loading-screen="enabled: false"
    renderer="antialias: true; logarithmicDepthBuffer: true;">
    <a-entity camera></a-entity>

    <a-assets timeout="0">
      <video id="video0" src="assets/Buchhaltung.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video1" src="assets/Customer_Service.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video2" src="assets/E_Commerce.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video3" src="assets/Fachinformatiker.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video4" src="assets/Lagerlogistik.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video5" src="assets/Mediengestalter.mp4" preload="none" crossorigin="anonymous" autoplay loop muted
        playsinline webkit-playsinline style="display:none;"></video>
      <video id="video6" src="assets/PKA.mp4" preload="none" crossorigin="anonymous" autoplay loop muted playsinline
        webkit-playsinline style="display:none;"></video>
      <video id="video7" src="assets/Studium.mp4" preload="none" crossorigin="anonymous" autoplay loop muted playsinline
        webkit-playsinline style="display:none;"></video>
    </a-assets>

    <script>
      const markerConfig = [
        {
          id: 'video0',
          src: 'assets/Buchhaltung.mp4',
          pattern: 'assets/pattern-0.patt'
        },
        {
          id: 'video1',
          src: 'assets/Customer_Service.mp4',
          pattern: 'assets/pattern-1.patt'
        },
        {
          id: 'video2',
          src: 'assets/E_Commerce.mp4',
          pattern: 'assets/pattern-2.patt'
        },
        {
          id: 'video3',
          src: 'assets/Fachinformatiker.mp4',
          pattern: 'assets/pattern-3.patt'
        },
        {
          id: 'video4',
          src: 'assets/Lagerlogistik.mp4',
          pattern: 'assets/pattern-4.patt'
        },
        {
          id: 'video5',
          src: 'assets/Mediengestalter.mp4',
          pattern: 'assets/pattern-5.patt'
        },
        {
          id: 'video6',
          src: 'assets/PKA.mp4',
          pattern: 'assets/pattern-6.patt'
        },
        {
          id: 'video7',
          src: 'assets/Studium.mp4',
          pattern: 'assets/pattern-7.patt'
        }
      ];

      const videoSettings = {
        width: 10.80,
        height: 19.20,
        position: '0 0 -4',
        rotation: '-90 0 0'
      };

      window.addEventListener('DOMContentLoaded', () => {
        const scene = document.querySelector('a-scene');

        markerConfig.forEach(config => {
          const marker = document.createElement('a-marker');
          marker.setAttribute('type', 'pattern');
          marker.setAttribute('url', config.pattern);
          marker.setAttribute('id', `marker-${config.id}`);
          marker.setAttribute('video-handler', `videoId: ${config.id}`);
          marker.setAttribute('emitevents', 'true');

          const video = document.createElement('a-video');
          video.setAttribute('id', `ar-${config.id}`);
          video.setAttribute('src', `#${config.id}`);
          video.setAttribute('width', videoSettings.width);
          video.setAttribute('height', videoSettings.height);
          video.setAttribute('position', videoSettings.position);
          video.setAttribute('rotation', videoSettings.rotation);
          video.setAttribute('visible', 'false');

          marker.appendChild(video);
          scene.appendChild(marker);
        });

        // Initialize videos but don't load them yet
        document.querySelectorAll('video').forEach(video => {
          video.pause();
          video.currentTime = 0;
          video.preload = 'none'; // Ensure no preloading
          // Remove src temporarily to prevent any automatic loading
          const originalSrc = video.src;
          video.removeAttribute('src');
          video.setAttribute('data-src', originalSrc);
        });
      });
    </script>
  </a-scene>

  <script>
    // Fixed distance stabilization
    AFRAME.registerComponent('marker-filter', {
      schema: {
        stabilityFrames: { type: 'number', default: 150 }, // 5 seconds at 30fps
        lockDistance: { type: 'number', default: 3 }, // Fixed distance from camera
        minStableFrames: { type: 'number', default: 60 }, // 2 seconds before reset
        movementThreshold: { type: 'number', default: 2.0 } // Enormous dead zone
      },

      init: function () {
        this.stablePosition = new THREE.Vector3();
        this.positionBuffer = [];
        this.bufferSize = 90; // 3 seconds of frames
        this.stableFrameCount = 0;
        this.isLocked = false;
        this.invisibleFrames = 0;
        this.lastPosition = new THREE.Vector3();
        this.frameCount = 0;
        this.lastUpdateTime = 0;
        
        // Initialize buffer
        for (let i = 0; i < this.bufferSize; i++) {
          this.positionBuffer.push(new THREE.Vector3());
        }
      },

      checkStability: function(currentPos) {
        // Only check every 4 frames to allow natural hand movement
        if (this.frameCount % 4 !== 0) return false;
        
        // Update buffer
        this.positionBuffer.shift();
        this.positionBuffer.push(currentPos.clone());
        
        // Check for stability with massive threshold
        const threshold = 1.0; // Extremely large stability threshold
        for (let i = 1; i < this.bufferSize; i++) {
          const dx = Math.abs(this.positionBuffer[i].x - this.positionBuffer[0].x);
          const dy = Math.abs(this.positionBuffer[i].y - this.positionBuffer[0].y);
          if (dx > threshold || dy > threshold) {
            return false;
          }
        }
        return true;
      },
      
      tick: function () {
        this.frameCount++;

        if (!this.el.object3D.visible) {
          this.invisibleFrames++;
          // Only reset after significant invisibility
          if (this.invisibleFrames > this.data.minStableFrames) {
            this.stableFrameCount = 0;
            this.isLocked = false;
            // Clear buffer
            for (let i = 0; i < this.bufferSize; i++) {
              this.positionBuffer[i].set(0, 0, 0);
            }
          }
          return;
        }

        this.invisibleFrames = 0;
        const currentPosition = this.el.object3D.position;

        if (!this.isLocked) {
          // Only update every 4 frames while seeking stability
          if (this.frameCount % 4 === 0) {
            if (this.checkStability(currentPosition)) {
              this.stableFrameCount++;
              
              if (this.stableFrameCount >= this.data.stabilityFrames) {
                // Use heavily rounded average position for extra stability
                let avgX = 0, avgY = 0;
                
                // Take middle 30% of samples to avoid outliers
                const start = Math.floor(this.bufferSize * 0.35);
                const end = Math.floor(this.bufferSize * 0.65);
                for (let i = start; i < end; i++) {
                  avgX += this.positionBuffer[i].x;
                  avgY += this.positionBuffer[i].y;
                }
                
                avgX /= (end - start);
                avgY /= (end - start);
                
                // Extreme rounding to prevent any micro-movements
                this.stablePosition.set(
                  Math.round(avgX * 2) / 2, // Round to nearest 0.5
                  Math.round(avgY * 2) / 2,
                  -this.data.lockDistance
                );
                this.lastPosition.copy(this.stablePosition);
                this.isLocked = true;
                this.lastUpdateTime = this.frameCount;
              }
            } else {
              this.stableFrameCount = 0;
            }
          }
          
          // Use current position with fixed distance while waiting
          this.el.object3D.position.copy(currentPosition);
          this.el.object3D.position.z = -this.data.lockDistance;
        } else {
          // Only check for movement every 60 frames (2 seconds)
          if (this.frameCount - this.lastUpdateTime >= 60) {
            const dx = Math.abs(currentPosition.x - this.lastPosition.x);
            const dy = Math.abs(currentPosition.y - this.lastPosition.y);
            
            // Only update if movement is massive
            if (dx > this.data.movementThreshold || dy > this.data.movementThreshold) {
              // Super aggressive rounding
              this.stablePosition.set(
                Math.round(currentPosition.x * 2) / 2, // Round to nearest 0.5
                Math.round(currentPosition.y * 2) / 2,
                -this.data.lockDistance
              );
              this.lastPosition.copy(this.stablePosition);
              this.lastUpdateTime = this.frameCount;
            }
          }
          
          // Use absolutely locked position
          this.el.object3D.position.copy(this.stablePosition);
        }

        // Completely fixed rotation
        this.el.object3D.rotation.set(THREE.MathUtils.degToRad(-90), 0, 0);
      }
    });

    let currentVideo = null;

    AFRAME.registerComponent("video-handler", {
      schema: {
        videoId: { type: 'string' }
      },

      init: function () {
        const marker = this.el;
        const videoEl = document.getElementById(this.data.videoId);
        const arVideo = document.getElementById(`ar-${this.data.videoId}`);
        let videoLoaded = false;

        videoEl.addEventListener('error', (e) => {
          console.error('Video error:', e.target.error);
        });

        marker.addEventListener("markerFound", () => {
          if (!videoLoaded) {
            // Restore src and load the video only when first detected
            if (!videoEl.src && videoEl.getAttribute('data-src')) {
              videoEl.src = videoEl.getAttribute('data-src');
            }
            videoEl.load();
            videoLoaded = true;
          }

          if (currentVideo && currentVideo !== videoEl) {
            currentVideo.pause();
            document.getElementById(`ar-${currentVideo.id}`).setAttribute("visible", false);
          }

          arVideo.setAttribute("visible", true);
          videoEl.play().then(() => {
            currentVideo = videoEl;
          }).catch(error => {
            console.error('Video playback failed:', error);
          });
        });

        marker.addEventListener("markerLost", () => {
          arVideo.setAttribute("visible", false);
          videoEl.pause();
        });
      },
    });
  </script>
</body>

</html>